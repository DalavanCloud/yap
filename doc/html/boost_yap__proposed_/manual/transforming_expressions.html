<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Transforming Expressions</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Boost.YAP (Proposed)">
<link rel="up" href="../manual.html" title="Manual">
<link rel="prev" href="operators.html" title="Operators">
<link rel="next" href="evaluating_expressions.html" title="Evaluating Expressions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="operators.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="evaluating_expressions.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_yap__proposed_.manual.transforming_expressions"></a><a class="link" href="transforming_expressions.html" title="Transforming Expressions">Transforming
      Expressions</a>
</h3></div></div></div>
<p>
        Transformations in Boost.YAP are done using the <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>
        function.
      </p>
<p>
        Let's take another look at the example expression from the intro:
      </p>
<p>
        <span class="inlinemediaobject"><img src="../../../../doc/expr.png" alt="expr"></span>
      </p>
<p>
        Consider a call to <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>,
        operatnig on that expression:
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span> <span class="identifier">xform</span><span class="special">);</span>
</pre>
<p>
        Boost.YAP's <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code> first looks at the top level
        expression, which is a <code class="computeroutput"><span class="special">+</span></code> expression.
        If <code class="computeroutput"><span class="identifier">xform</span></code> matches the <code class="computeroutput"><span class="special">+</span></code> expression, <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>
        is done; it just returns <code class="computeroutput"><span class="identifier">xform</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span></code>.
        If <code class="computeroutput"><span class="identifier">xform</span></code> does not match the
        <code class="computeroutput"><span class="special">+</span></code> expression, <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code> transforms all its operands
        (which for <code class="computeroutput"><span class="keyword">operator</span><span class="special">+()</span></code>
        is just the left and right operands), and returns a new <code class="computeroutput"><span class="special">+</span></code>
        expression with those transformed operands. What I mean by "match"
        is covered in detail below.
      </p>
<p>
        The overall effect of this is that <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>
        effectively copies an <code class="computeroutput"><span class="identifier">expr</span></code>
        node that does not match <code class="computeroutput"><span class="identifier">xform</span></code>,
        and returns a transformed node for an <code class="computeroutput"><span class="identifier">expr</span></code>
        node that does not match <code class="computeroutput"><span class="identifier">xform</span></code>.
      </p>
<p>
        <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code> can also take multiple transform
        objects. If you call it with N transform objects, it will attempt to match
        each of the N transforms to a given expression, one at a time and in their
        given order. Only if no transform matches an expression does the copy-and-recurse
        behavior kick in.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          There's another form of <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>,
          <code class="computeroutput"><a class="link" href="../../boost/yap/transform_strict.html" title="Function template transform_strict">transform_strict()</a></code>. <code class="computeroutput"><a class="link" href="../../boost/yap/transform_strict.html" title="Function template transform_strict">transform_strict()</a></code>
          is identical to <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>
          except that it does not copy or recurse into an unmatched expression. Instead,
          a failed match is a hard error. This is useful when you have written a
          transform that you expect to completely match an expression, and you want
          the compiler to tell you if you've made a mistake.
        </p></td></tr>
</table></div>
<p>
        One common result of calling <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>
        is that you create a copy of <code class="computeroutput"><span class="identifier">expr</span></code>,
        with a few matching nodes transformed. But this does not hav to be the result
        of calling <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>, because a Boost.YAP transformation
        is free-form; it must return a value, but may do just about anything else.
        It can transform an expression into anything &#8212; a new expression of
        any kind, or even a non-expression value (effectively evaluating the expression).
        As before, here is the <code class="computeroutput"><span class="identifier">get_arity</span></code>
        transform from the <a class="link" href="examples/calc3.html" title="Calc3">Calc3</a>
        example. It returns a value, not an <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expression">Expression</a>:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">get_arity</span>
<span class="special">{</span>
    <span class="comment">// Base case 1: Match a placeholder terminal, and return its arity as the</span>
    <span class="comment">// result.</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">long</span> <span class="keyword">long</span> <span class="identifier">I</span><span class="special">&gt;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">llong</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_tag</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&gt;,</span>
                                      <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">placeholder</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;)</span>
    <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">llong_c</span><span class="special">&lt;</span><span class="identifier">I</span><span class="special">&gt;;</span> <span class="special">}</span>

    <span class="comment">// Base case 2: Match any other terminal.  Return 0; non-placeholders to</span>
    <span class="comment">// not contribute to arity.</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_tag</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&gt;,</span> <span class="identifier">T</span> <span class="special">&amp;&amp;)</span>
    <span class="special">{</span>
        <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="number">0</span><span class="identifier">_c</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Recursive case: Match any expression not covered above, and return the</span>
    <span class="comment">// maximum of its children's arities.</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_kind</span> <span class="identifier">Kind</span><span class="special">,</span> <span class="keyword">typename</span><span class="special">...</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
    <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_tag</span><span class="special">&lt;</span><span class="identifier">Kind</span><span class="special">&gt;,</span> <span class="identifier">Arg</span> <span class="special">&amp;&amp;...</span> <span class="identifier">arg</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">maximum</span><span class="special">(</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">make_tuple</span><span class="special">(</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">Arg</span><span class="special">&gt;(</span><span class="identifier">arg</span><span class="special">),</span> <span class="identifier">get_arity</span><span class="special">{})...</span>
            <span class="special">)</span>
        <span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        Also, note that in this case the transform is stateless, but you could also
        give your transforms data members containing contextual state:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">take_nth</span>
<span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_tag</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&gt;,</span>
                     <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">vec</span><span class="special">)</span>
    <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">make_terminal</span><span class="special">(</span><span class="identifier">vec</span><span class="special">[</span><span class="identifier">n</span><span class="special">]);</span> <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">n</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          Often when you create an expression, you will want to evaluate it in different
          contexts, changing its evaluation &#8212; or even entire meaning &#8212;
          in each context. <code class="computeroutput"><a class="link" href="../../boost/yap/evaluate.html" title="Function template evaluate">evaluate()</a></code>
          is wrong for this task, since it only takes values for substitution into
          placeholders. In these situations, you should instead use multiple transforms
          that evaluate your expression in different ways.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_yap__proposed_.manual.transforming_expressions.h0"></a>
        <span class="phrase"><a name="boost_yap__proposed_.manual.transforming_expressions.when__functionname_alt__boost__yap__transform___code__phrase_role__identifier__transform__phrase__phrase_role__special______phrase___code___functionname__recurses"></a></span><a class="link" href="transforming_expressions.html#boost_yap__proposed_.manual.transforming_expressions.when__functionname_alt__boost__yap__transform___code__phrase_role__identifier__transform__phrase__phrase_role__special______phrase___code___functionname__recurses">When
        transform() Recurses</a>
      </h5>
<p>
        As described above, <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>
        only recurses when it <span class="bold"><strong>does not</strong></span> find a match.
        This means that if you want to transform a nonterminal, say an <code class="computeroutput"><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">call</span></code> expression we'll call <code class="computeroutput"><span class="identifier">C</span></code>, and <span class="bold"><strong>also</strong></span>
        <code class="computeroutput"><span class="identifier">C</span></code>'s subexpressions, you must
        explicitly call <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code> yourself in your transform
        that matches <code class="computeroutput"><span class="identifier">C</span></code>. You can see
        this kind of explicit <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>
        call in the recursive case of <code class="computeroutput"><span class="identifier">get_arity</span></code>
        in the example code above.
      </p>
<h5>
<a name="boost_yap__proposed_.manual.transforming_expressions.h1"></a>
        <span class="phrase"><a name="boost_yap__proposed_.manual.transforming_expressions.transform_matching"></a></span><a class="link" href="transforming_expressions.html#boost_yap__proposed_.manual.transforming_expressions.transform_matching">Transform
        Matching</a>
      </h5>
<p>
        In Boost.YAP a <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.transform">Transform</a>
        is a <a href="http://en.cppreference.com/w/cpp/concept/Callable" target="_top">Callable</a>
        that has <span class="bold"><strong>zero or more</strong></span> overloads that model
        the <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransform</a>
        or <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        concepts.
      </p>
<p>
        An <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransform</a>
        overload takes the expression to be transformed. Here's one from a transform
        object in the <a class="link" href="examples/future_group.html" title="Future Group">Future
        Group</a> example:
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Transform left || right -&gt; transform(left).</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()</span> <span class="special">(</span>
    <span class="identifier">future_expr</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">logical_or</span><span class="special">,</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">U</span><span class="special">&gt;</span>
    <span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">or_expr</span>
<span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Recursively transform the left side, and return the result.</span>
    <span class="comment">// Without the recursion, we might return a terminal expression here</span>
    <span class="comment">// insead of a tuple.</span>
    <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">left</span><span class="special">(</span><span class="identifier">or_expr</span><span class="special">),</span> <span class="special">*</span><span class="keyword">this</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransforms</a>
        are most useful when you want to transform a narrow set of expression types
        (perhaps only one). In particular, you can distinguish between <code class="computeroutput"><span class="keyword">const</span></code> and non-<code class="computeroutput"><span class="keyword">const</span></code>,
        reference and non-reference, etc., in the expression and its operands in
        a way that you have less control over with the other kind of transform.
      </p>
<p>
        A <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        overload takes a tag that indicates the <code class="computeroutput"><a class="link" href="../../boost/yap/expr_kind.html" title="Type expr_kind">expr_kind</a></code> of the expression
        to be transformed, and then (loosely) the value of each operand of the expression
        to be transformed. Here's one from the <a class="link" href="examples/pipable_algorithms.html" title="Pipable Algorithms">Pipable
        Algorithms</a> example:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Range</span><span class="special">&gt;</span>
<span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()(</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_tag</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">call</span><span class="special">&gt;,</span>
    <span class="identifier">algorithm_t</span> <span class="identifier">a</span><span class="special">,</span>
    <span class="identifier">Range</span> <span class="special">&amp;</span> <span class="identifier">r</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">call_algorithm</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">r</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransforms</a>
        are most useful when the transform needs to match an expression without regard
        to whether its operands are <a class="link" href="../../boost/yap/expr_kind.html#boost.yap.expr_kind.expr_ref"><code class="computeroutput"><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">expr_ref</span></code></a> expressions, or &#8212;
        if they are terminals &#8212; whether they contain or refer to their values.
        <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransforms</a>
        tend to be far more concise.
      </p>
<h5>
<a name="boost_yap__proposed_.manual.transforming_expressions.h2"></a>
        <span class="phrase"><a name="boost_yap__proposed_.manual.transforming_expressions.a_more_rigorous_description_of_tagtransform_parameters"></a></span><a class="link" href="transforming_expressions.html#boost_yap__proposed_.manual.transforming_expressions.a_more_rigorous_description_of_tagtransform_parameters">A
        More Rigorous Description of TagTransform Parameters</a>
      </h5>
<p>
        That "(loosely)" before probably bothered you, right? Me too. Each
        non-tag parameter is passed to a <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        by calling an operand accessor appropriate to <code class="computeroutput"><span class="identifier">expr</span></code>'s
        kind, and then calling a terminal-specific version of <code class="computeroutput"><a class="link" href="../../boost/yap/value.html" title="Function template value">value()</a></code>
        (<code class="computeroutput"><span class="identifier">terminal_value</span><span class="special">()</span></code>)
        on the result. For example, consider a plus expression <code class="computeroutput"><span class="identifier">expr</span></code>.
        The <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        on a transform object <code class="computeroutput"><span class="identifier">xform</span></code>
        would be called like this:
      </p>
<pre class="programlisting"><span class="identifier">xform</span><span class="special">(</span><span class="identifier">plus_tag</span><span class="special">,</span> <span class="identifier">terminal_value</span><span class="special">(</span><span class="identifier">left</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)),</span> <span class="identifier">terminal_value</span><span class="special">(</span><span class="identifier">right</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)))</span>
</pre>
<p>
        The operand accessors (<code class="computeroutput"><a class="link" href="../../boost/yap/left.html" title="Function template left">left()</a></code>
        and <code class="computeroutput"><a class="link" href="../../boost/yap/right.html" title="Function template right">right()</a></code> in this example) all dereference
        <a class="link" href="../../boost/yap/expr_kind.html#boost.yap.expr_kind.expr_ref"><code class="computeroutput"><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">expr_ref</span></code></a>
        expressions before operating on them, and <code class="computeroutput"><span class="identifier">terminal_value</span><span class="special">()</span></code> does the same.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">terminal_value</span><span class="special">()</span></code>
        works much like <code class="computeroutput"><a class="link" href="../../boost/yap/value.html" title="Function template value">value()</a></code>, except that it does not
        take the value of a <span class="bold"><strong>nonterminal</strong></span> unary expression;
        it just forwards a nonterminal through. It still takes values out of terminals
        and unwraps <a class="link" href="../../boost/yap/expr_kind.html#boost.yap.expr_kind.expr_ref"><code class="computeroutput"><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">expr_ref</span></code></a>
        expressions, though.
      </p>
<p>
        The auto-unwrapping of terminals means that you can effectively ignore the
        presence of <a class="link" href="../../boost/yap/expr_kind.html#boost.yap.expr_kind.expr_ref"><code class="computeroutput"><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">expr_ref</span></code></a>
        expressions when writing a <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>.
        You can also just deal with the values inside terminals, and not the terminals
        themselves. Also, you can match all terminal value qualifiers (<code class="computeroutput"><span class="keyword">const</span></code> or not, lvalue or rvalue) uniformly
        with a <code class="computeroutput"><span class="identifier">T</span> <span class="keyword">const</span>
        <span class="special">&amp;</span></code> parameter. Finally, you can
        write <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        parameter types that can catch conversions; for instance, you can match any
        negation expression containing a terminal, <span class="bold"><strong>or a reference
        to one</strong></span>, containing a value convertible to <code class="computeroutput"><span class="keyword">double</span></code>
        like this:
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">xform</span>
<span class="special">{</span>
    <span class="keyword">auto</span> <span class="keyword">operator</span><span class="special">()</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">negate_tag</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">x</span><span class="special">)</span>
    <span class="special">{</span> <span class="keyword">return</span> <span class="comment">/* ... */</span><span class="special">;</span> <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
        That will match a negation of a terminal containing an <code class="computeroutput"><span class="keyword">unsigned</span>
        <span class="keyword">int</span></code>, <code class="computeroutput"><span class="keyword">unsigned</span>
        <span class="keyword">int</span> <span class="special">&amp;</span></code>,
        <code class="computeroutput"><span class="keyword">int</span> <span class="keyword">const</span>
        <span class="special">&amp;</span></code>, <code class="computeroutput"><span class="keyword">float</span>
        <span class="special">&amp;&amp;</span></code>, etc. It will also match
        a negation of a reference to such a terminal.
      </p>
<h5>
<a name="boost_yap__proposed_.manual.transforming_expressions.h3"></a>
        <span class="phrase"><a name="boost_yap__proposed_.manual.transforming_expressions.mixing_the_two_kinds_of_transforms"></a></span><a class="link" href="transforming_expressions.html#boost_yap__proposed_.manual.transforming_expressions.mixing_the_two_kinds_of_transforms">Mixing
        the Two Kinds of Transforms</a>
      </h5>
<p>
        You can have two overloads in your transform that match an expression, one
        an <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransform</a>
        and one a <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>,
        and there will not be any ambiguity. The <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        is matched first, and the <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransform</a>
        is matched only if the <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        did not. You don't have to worry about ambiguity, but save yourself some
        confusion and mix the two kinds of overloads as little as possible.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The above only applies when you have an <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransform</a>
          and a <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
          that match <span class="bold"><strong>the same kind of expression</strong></span>.
          Having unrelated <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransforms</a>
          and <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransforms</a>
          within the same transform object is often quite useful.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_yap__proposed_.manual.transforming_expressions.h4"></a>
        <span class="phrase"><a name="boost_yap__proposed_.manual.transforming_expressions.multiple_transform_objects"></a></span><a class="link" href="transforming_expressions.html#boost_yap__proposed_.manual.transforming_expressions.multiple_transform_objects">Multiple
        Transform Objects</a>
      </h5>
<p>
        In the case that multiple transform objects are being used in <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code>, the above logic applies
        to each one independently before the next one is used. In other words, in
        the call <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span><span class="identifier">expr</span><span class="special">,</span>
        <span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span></code>, <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code> tries to match any <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        from <code class="computeroutput"><span class="identifier">a</span></code> to an expression first,
        then any <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransform</a>
        from <code class="computeroutput"><span class="identifier">a</span></code>, then any <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.tagtransform">TagTransform</a>
        from <code class="computeroutput"><span class="identifier">b</span></code>, and finally any
        <a class="link" href="../concepts.html#boost_yap__proposed_.concepts.expressiontransform">ExpressionTransform</a>
        from <code class="computeroutput"><span class="identifier">b</span></code>.
      </p>
<h5>
<a name="boost_yap__proposed_.manual.transforming_expressions.h5"></a>
        <span class="phrase"><a name="boost_yap__proposed_.manual.transforming_expressions.yap_supplied_transforms"></a></span><a class="link" href="transforming_expressions.html#boost_yap__proposed_.manual.transforming_expressions.yap_supplied_transforms">YAP-Supplied
        Transforms</a>
      </h5>
<p>
        Boost.YAP comes with a couple of functions that return ready-made transforms,
        <code class="computeroutput"><a class="link" href="../../boost/yap/replacements.html" title="Function template replacements">replacements()</a></code> and <code class="computeroutput"><a class="link" href="../../boost/yap/evaluation.html" title="Function template evaluation">evaluation()</a></code>.
      </p>
<p>
        The transforms returned by <code class="computeroutput"><a class="link" href="../../boost/yap/replacements.html" title="Function template replacements">replacements()</a></code>
        replace only placeholder terminals. Placeholder <code class="computeroutput"><span class="identifier">I</span></code>
        is replaced by the <code class="computeroutput"><span class="identifier">I</span><span class="special">-</span><span class="number">1</span></code>-th argument passed to <code class="computeroutput"><a class="link" href="../../boost/yap/replacements.html" title="Function template replacements">replacements()</a></code>.
        Placeholders are <code class="computeroutput"><span class="number">1</span></code>-based for
        consistency with other Boost and <code class="computeroutput"><span class="identifier">std</span></code>
        placeholders.
      </p>
<p>
        There are also a couple of specialty transform functions, <code class="computeroutput"><a class="link" href="../../boost/yap/replace_placeholders.html" title="Function template replace_placeholders">replace_placeholders()</a></code>
        and <code class="computeroutput"><a class="link" href="../../boost/yap/evaluate.html" title="Function template evaluate">evaluate()</a></code>. These are convenience functions
        that just call <code class="computeroutput"><a class="link" href="../../boost/yap/transform.html" title="Function template transform">transform()</a></code> on an expression using
        <code class="computeroutput"><a class="link" href="../../boost/yap/replacements.html" title="Function template replacements">replacements()</a></code> or <code class="computeroutput"><a class="link" href="../../boost/yap/evaluation.html" title="Function template evaluation">evaluation()</a></code>
        as the transform, respectively.
      </p>
<p>
        The behavior of <code class="computeroutput"><a class="link" href="../../boost/yap/evaluation.html" title="Function template evaluation">evaluation()</a></code>
        is covered in the next section, <a class="link" href="evaluating_expressions.html" title="Evaluating Expressions">Evaluating
        Expressions</a>.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="operators.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../manual.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="evaluating_expressions.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
